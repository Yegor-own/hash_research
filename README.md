# Исследование влияния хеш-функции на алгоритм Рабина-Карпа

## 1. Введение

Поиск подстроки в тексте является одной из базовых задач алгоритмики и обработки строк. Одним из известных алгоритмов решения данной задачи является алгоритм Рабина–Карпа, основанный на использовании хеш-функций для ускорения сравнения подстрок.

Эффективность алгоритма Рабина–Карпа напрямую зависит от выбора хеш-функции. С одной стороны, хеш-функция должна быть вычислительно дешёвой, с другой — обладать низкой вероятностью коллизий. В данной работе проводится экспериментальное исследование нескольких хеш-функций с целью анализа их производительности и устойчивости к коллизиям.

## 2. Алгоритм Рабина–Карпа

Алгоритм Рабина–Карпа использует скользящее хеширование:
1. Вычисляется хеш шаблона длины m
2. Вычисляется хеш первого окна текста длины m
3. При совпадении хешей выполняется посимвольное сравнение
4. Хеш следующего окна вычисляется за O(1)

Теоретическая сложность:
- Лучший / средний случай: ``O(n + m)``
- Худший случай (много коллизий): ``O(n·m)``

Таким образом, качество хеш-функции критически влияет на реальную производительность алгоритма.

## 3. Рассматриваемые хеш-функции и обоснование выбора

В исследовании были выбраны следующие хеш-функции:

### 3.1 sum: сумма кодов символов
```
H = Σ s[i]
```
Алгоритмическая сложность: ``O(m)``

Причины выбора:
- минимальная вычислительная сложность
- используется как базовый (наивный) ориентир

Недостатки:
- не учитывает порядок символов
- высокая вероятность коллизий

### 3.2 djb2 (Bernstein hash)
```
H = H * 33 + s[i]
```
Алгоритмическая сложность: ``O(m)``

Причины выбора:
- широко используется на практике
- простая и быстрая реализация
- лучшее распределение, чем у sum

### 3.3 poly_mod: полиномиальный хеш с модулем
```
H = (H * p + s[i]) mod M
```
Алгоритмическая сложность: ``O(m)``

где:
- p - основание
- M - большое простое число

Причины выбора:
- классический вариант для Рабина–Карпа
- хорошее распределение
- низкая вероятность коллизий
- фиксированная разрядность

### 3.4 poly_nomod: полиномиальный хеш без модуля (BigInt)
```
H = Σ s[i] · p^(m-1-i)
```
Алгоритмическая сложность: ``O(m)`` (операции умножения и сложения выполняются над числами произвольной точности, что увеличивает фактическую сложность)

Причины выбора:
- теоретически минимальная вероятность коллизий
- используется для сравнения с практичными реализациями

## 4. Особенности реализации
### 4.1 Язык и среда
- Язык реализации: Go
- Использованы собственные реализации хеш-функций
- Замеры времени производились в наносекундах

### 4.2 Скользящий хеш

Для poly_mod и poly_nomod реализовано скользящее обновление хеша:
```
H_new = (H_old - left * p^(m-1)) * p + right
```
где ``left`` - символ, покидающий окно, ``right`` - добавляемый символ

Это позволяет обновлять хеш окна за ``O(1)``.

### 4.3 Подсчёт метрик

В процессе эксперимента фиксировались:
1. время выполнения
2. количество совпадений хешей
3. количество коллизий
4. количество истинных совпадений
5. число посимвольных сравнений

## 5. Экспериментальная часть
### 5.1 Наборы данных

Использовались тексты различных типов:
- lorem - шаблонный текст
- alice - Алиса в стране чудес
- dna - ДНК (алфавит из 4 символов)
- random_X - случайные строки

### 5.2 Параметры экспериментов
#### 5.2.1 Эксперимент 1 (pattern_length.csv)
- фиксированная длина текста
- варьируемая длина шаблона: 2, 4, 8, 16, 32, 64, 128, 256, 512
#### 5.2.2 Эксперимент 2 (text_length.csv)
- фиксированная длина шаблона: 32
- варьируемая длина текста

## 6. Анализ результатов
### 6.1 Время выполнения

[![эксперимент 1, текст: lorem](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/time_lorem.png "Эксперимент 1, текст: lorem")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/time_lorem.png)
Эксперимент 1, текст: lorem

[![эксперимент 1, текст: днк](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/time_dna.png "Эксперимент 1, текст: днк")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/time_dna.png)
Эксперимент 1, текст: днк

[![эксперимент 1 без poly_nomod, текст: днк](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern_without_pily_nomod/time_dna.png "Эксперимент 1 без poly_nomod, текст: днк")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern_without_pily_nomod/time_dna.png)
Эксперимент 1 без poly_nomod, текст: днк

[![эксперимент 1, текст: Алиса](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/time_alice.png "Эксперимент 1, текст: Алиса")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/time_alice.png)
Эксперимент 1, текст: Алиса

[![эксперимент 2](https://github.com/Yegor-own/hash_research/blob/master/plots/text/time_vs_text_length.png "Эксперимент 2")](https://github.com/Yegor-own/hash_research/blob/master/plots/text/time_vs_text_length.png)
Эксперимент 2

``poly_nomod`` показал наихудшее время выполнения (рост времени обусловлен использованием BigInt)

``poly_mod`` стабильно демонстрирует сопоставимое или лучшее время выполнения по сравнению с ``sum`` и ``djb2``, при этом обеспечивая значительно меньшее количество коллизий

### 6.2 Коллизии

[![эксперимент 1, текст: lorem](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/collisions_lorem.png "Эксперимент 1, текст: lorem")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/collisions_lorem.png)

[![эксперимент 1, текст: днк](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/collisions_dna.png "Эксперимент 1, текст: днк")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/collisions_dna.png)

[![эксперимент 1 без poly_nomod, текст: днк](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern_without_pily_nomod/collisions_dna.png "Эксперимент 1 без poly_nomod, текст: днк")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern_without_pily_nomod/collisions_dna.png)
Эксперимент 1 без poly_nomod, текст: днк

[![эксперимент 1, текст: Алиса](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/collisions_alice.png "Эксперимент 1, текст: Алиса")](https://github.com/Yegor-own/hash_research/blob/master/plots/pattern/collisions_alice.png)

[![эксперимент 2](https://github.com/Yegor-own/hash_research/blob/master/plots/text/collisions_vs_text_length.png "Эксперимент 2")](https://github.com/Yegor-own/hash_research/blob/master/plots/text/collisions_vs_text_length.png)

**Остальные графики можно посмотреть в папке ``plots``**

``sum`` и ``djb2`` показали значительное число коллизий

``poly_nomod`` практически не имеет коллизий

``poly_mod`` обеспечивает минимальное число коллизий при высокой скорости

### 6.3 Компромисс скорость / надёжность (poly_mod vs poly_nomod)

Эксперимент подтвердил, что отказ от модуля снижает число коллизий, однако приводит к резкому ухудшению производительности, что делает такой подход непрактичным.

### 6.4 Влияние размера алфавита

В текстах с малым алфавитом (DNA, алфавит из 4 символов) наблюдается значительный рост числа коллизий для простых хеш-функций (``sum``, ``djb2``). Это связано с высокой вероятностью совпадений хешей при ограниченном количестве возможных подстрок.

Полиномиальный хеш с модулем сохраняет устойчивость к коллизиям независимо от размера алфавита.


### 7. Заключение

В результате исследования было показано, что полиномиальный хеш с модулем является наиболее эффективным вариантом для алгоритма Рабина–Карпа, обеспечивая оптимальный баланс между производительностью и вероятностью коллизий.

### 8. Описание директорий и файлов
``main.go`` - главный запускаемый файл

``utils.go`` - вспомогательные функции для проведения экспериментов

``pattern_len_graph.py``, ``text_len_graph.py`` - python скрипты для геренации диаграмм

``plots`` - директория с изображениями диаграмм

``output`` - директория с csv файлами статистики

``data`` - директория с txt файлами данных

``hash`` - директория с исходными файлами хэш-функций

``rk`` - директория с исходными файлами алгоритма Рабина-Карпа


### 9. Источники
<a href="https://stackoverflow.com/q/11546791" target="_blank">Этот вопрос на StackOverflow помог мне с выбором хэш-функций</a>

<a href="https://stackoverflow.com/a/71694031" target="_blank">Из этого ответа подчерпнул идею взять sum и poly-функции</a>

<a href="https://stackoverflow.com/a/11547444" target="_blank">Из этого ответа подчерпнул идею взять djb2</a>

<a href="https://www.biointeractive.org/sites/default/files/Anolis-DNA-sequences.txt" target="_blank">Оригинал файла ДНК</a>

<a href="https://gist.githubusercontent.com/phillipj/4944029/raw/75ba2243dd5ec2875f629bf5d79f6c1e4b5a8b46/alice_in_wonderland.txt" target="_blank">Оригинал файла Алисы</a>